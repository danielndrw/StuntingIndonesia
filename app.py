# -*- coding: utf-8 -*-
"""app

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1zYTQrzw4n6dTT3PZ44hCY9qsoNeg4k8d
"""

# ================================================================
# STREAMLIT APP - STUNTING INDONESIA DASHBOARD (FINAL FIXED VERSION)
# ================================================================

import streamlit as st
import pandas as pd
import numpy as np
import plotly.express as px
import joblib, os, json, requests

# ================================================================
# SETUP DASHBOARD
# ================================================================
st.set_page_config(page_title="📊 Dashboard Stunting Indonesia", layout="wide")
st.title("🇮🇩 Dashboard Analisis Stunting Indonesia")
st.markdown("### *Clustering, Klasifikasi, dan Prediksi Stunting berbasis data sosio-ekonomi*")
st.markdown("---")

# ================================================================
# LOAD DATA
# ================================================================
@st.cache_data
def load_data():
    return pd.read_excel("DATA_SUM_STUNTING.xlsx")

df = load_data()

# Pastikan kolom 'Provinsi' ada untuk pemetaan
if "Provinsi" not in df.columns:
    st.error("❌ Kolom 'Provinsi' tidak ditemukan di dataset. Pastikan file DATA_SUM_STUNTING.xlsx memiliki kolom 'Provinsi'.")
    st.stop()

# ================================================================
# PREPROCESSING (HANDLE NaN, STRING, KOLOM NUMERIK)
# ================================================================
def clean_input_data(df_in: pd.DataFrame) -> pd.DataFrame:
    df_clean = df_in.copy()
    for col in df_clean.columns:
        if df_clean[col].dtype == object:
            # ganti koma -> titik lalu coerce ke numeric
            df_clean[col] = df_clean[col].replace(",", ".", regex=True)
            df_clean[col] = pd.to_numeric(df_clean[col], errors="coerce")
    # isi NaN numerik dengan median kolom
    df_clean = df_clean.fillna(df_clean.median(numeric_only=True))
    return df_clean

# simpan versi cleaned untuk visual (non-prediksi tetap pakai df asli bila perlu)
df_num = clean_input_data(df.select_dtypes(include=[np.number]))

# ================================================================
# GEOJSON LOADER (ONLINE → LOKAL → DUMMY TITIK)
# ================================================================
PROV_COORDS = {
    "ACEH": (4.70, 96.75), "SUMATERA UTARA": (2.11, 99.55), "SUMATERA BARAT": (-0.74, 100.80),
    "RIAU": (0.29, 101.71), "KEPULAUAN RIAU": (0.92, 104.45), "JAMBI": (-1.61, 103.61),
    "SUMATERA SELATAN": (-3.32, 104.91), "BENGKULU": (-3.58, 102.35), "LAMPUNG": (-4.56, 105.41),
    "KEP. BANGKA BELITUNG": (-2.74, 106.44), "BANTEN": (-6.41, 106.06), "DKI JAKARTA": (-6.17, 106.83),
    "JAWA BARAT": (-6.89, 107.64), "JAWA TENGAH": (-7.15, 110.14), "D I YOGYAKARTA": (-7.79, 110.37),
    "JAWA TIMUR": (-7.54, 112.24), "BALI": (-8.34, 115.09), "NUSA TENGGARA BARAT": (-8.65, 117.36),
    "NUSA TENGGARA TIMUR": (-8.66, 121.08), "KALIMANTAN BARAT": (-0.13, 111.10), "KALIMANTAN TENGAH": (-1.68, 113.38),
    "KALIMANTAN SELATAN": (-3.09, 115.28), "KALIMANTAN TIMUR": (0.54, 116.42), "KALIMANTAN UTARA": (2.84, 117.39),
    "SULAWESI UTARA": (1.49, 124.84), "GORONTALO": (0.70, 122.45), "SULAWESI TENGAH": (-1.43, 121.45),
    "SULAWESI BARAT": (-2.84, 119.23), "SULAWESI SELATAN": (-3.67, 119.97), "SULAWESI TENGGARA": (-4.14, 122.17),
    "MALUKU": (-3.24, 130.15), "MALUKU UTARA": (1.57, 127.81), "PAPUA": (-4.27, 138.08),
    "PAPUA BARAT": (-1.34, 133.17), "PAPUA BARAT DAYA": (-0.88, 131.26), "PAPUA PEGUNUNGAN": (-4.10, 138.94),
    "PAPUA SELATAN": (-8.49, 140.40), "PAPUA TENGAH": (-3.36, 135.50)
}

@st.cache_data
def load_geojson():
    # URL aktif per 2025-10; gunakan raw file provinsi
    url = "https://raw.githubusercontent.com/superpikar/indonesia-geojson/master/indonesia-prov.geojson"
    try:
        r = requests.get(url, timeout=10)
        r.raise_for_status()
        st.success("🌍 GeoJSON berhasil dimuat dari sumber online.")
        return r.json()
    except Exception as e:
        st.warning(f"⚠️ Gagal memuat GeoJSON online: {e}")

    # fallback lokal
    local_path = "indonesia_province.geojson"
    if os.path.exists(local_path):
        try:
            with open(local_path, "r", encoding="utf-8") as f:
                st.info("📁 Menggunakan GeoJSON lokal sebagai cadangan.")
                return json.load(f)
        except Exception as e:
            st.warning(f"⚠️ GeoJSON lokal bermasalah: {e}")

    # fallback dummy titik (tetap bisa divisualisasikan sebagai scatter_geo jika perlu)
    st.error("❌ Tidak ada GeoJSON valid. Menggunakan koleksi titik koordinat manual.")
    dummy = {"type": "FeatureCollection", "features": []}
    for prov, (lat, lon) in PROV_COORDS.items():
        dummy["features"].append({
            "type": "Feature",
            "properties": {"Propinsi": prov},
            "geometry": {"type": "Point", "coordinates": [lon, lat]},
        })
    return dummy

geojson = load_geojson()

# ================================================================
# LOAD MODELS & METADATA FITUR
# ================================================================
@st.cache_resource
def load_models():
    cluster = joblib.load("models/cluster_model.pkl")
    clf = joblib.load("models/classification_model.pkl")
    reg = joblib.load("models/regression_model.pkl")
    features_json = None
    try:
        with open("models/expected_features.json", "r", encoding="utf-8") as f:
            features_json = json.load(f)
    except Exception:
        features_json = None

    # ambil feature_names_in_ bila ada
    model_features = {
        "cluster": getattr(cluster, "feature_names_in_", None),
        "clf": getattr(clf, "feature_names_in_", None),
        "reg": getattr(reg, "feature_names_in_", None),
    }
    return cluster, clf, reg, model_features, features_json

cluster_model, clf_model, reg_model, model_features, expected = load_models()
if expected is None:
    expected = {"features_base": None, "features_all": None}

def get_feature_list(model_role: str, model_feat_names, expected_meta) -> list:
    """
    model_role: 'cluster' | 'clf' | 'reg'
    Prioritas: metadata JSON → feature_names_in_ → seluruh kolom numerik (fallback).
    """
    if model_role == "cluster":
        if expected_meta.get("features_base"):
            return expected_meta["features_base"]
    else:  # clf / reg
        if expected_meta.get("features_all"):
            return expected_meta["features_all"]

    if model_feat_names is not None:
        return list(model_feat_names)

    st.warning("⚠️ Metadata fitur tidak ditemukan. Menggunakan semua kolom numerik sebagai fallback.")
    return df.select_dtypes(include=[np.number]).columns.tolist()

# ================================================================
# SIDEBAR NAVIGASI
# ================================================================
st.sidebar.title("📁 Pilih Fitur Analisis")
mode = st.sidebar.radio("Pilih mode:", ["🧭 Clustering", "🏥 Klasifikasi Kesehatan", "📈 Prediksi Stunting"])

# ================================================================
# UTIL: GAMBAR CHOROPLETH AMAN (bila GeoJSON poligon)
# ================================================================
def draw_choropleth(dataframe, color_col, title, color_scale="RdYlGn_r", discrete=False, discrete_map=None):
    try:
        if discrete:
            fig = px.choropleth(
                dataframe,
                geojson=geojson,
                featureidkey="properties.Propinsi",     # sesuaikan dengan properti di GeoJSON
                locations="Provinsi",                   # sesuaikan dengan nama kolom provinsi di data
                color=color_col,
                color_discrete_map=discrete_map or {},
                title=title
            )
        else:
            fig = px.choropleth(
                dataframe,
                geojson=geojson,
                featureidkey="properties.Propinsi",
                locations="Provinsi",
                color=color_col,
                color_continuous_scale=color_scale,
                title=title
            )
        fig.update_geos(fitbounds="locations", visible=False)
        st.plotly_chart(fig, use_container_width=True)
    except Exception as e:
        st.error(f"❌ Gagal menggambar peta choropleth: {e}")
        st.write("Menampilkan tabel ringkas sebagai pengganti:")
        st.dataframe(dataframe[[ "Provinsi", color_col ]].head(10))

# ================================================================
# MODE: CLUSTERING
# ================================================================
if mode == "🧭 Clustering":
    st.subheader("🧭 Clustering Tingkat Kerentanan Stunting per Provinsi")

    try:
        feat_cluster = get_feature_list("cluster", model_features["cluster"], expected)
        # slice sesuai fitur training
        Xc = clean_input_data(df[feat_cluster].copy())
        # karena model cluster disimpan sebagai Pipeline(StandardScaler -> KMeans),
        # kita bisa langsung predict:
        cluster_labels = cluster_model.predict(Xc)

        df_vis = df.copy()
        df_vis["Cluster"] = cluster_labels
        cluster_map = {0: "Sejahtera (Maju)", 1: "Sedang (Mainstream)", 2: "Rentan (Tertinggal)"}
        df_vis["Kategori_Cluster"] = df_vis["Cluster"].map(cluster_map)

        draw_choropleth(
            df_vis,
            color_col="Kategori_Cluster",
            title="🗺️ Peta Clustering Kerentanan Stunting",
            discrete=True,
            discrete_map={"Sejahtera (Maju)": "green", "Sedang (Mainstream)": "orange", "Rentan (Tertinggal)": "red"}
        )

        st.caption("ℹ️ Keterangan: Warna hijau = Sejahtera (Maju), Oranye = Sedang (Mainstream), Merah = Rentan (Tertinggal).")
    except Exception as e:
        st.error(f"❌ Gagal menjalankan clustering: {e}")

# ================================================================
# MODE: KLASIFIKASI
# ================================================================
elif mode == "🏥 Klasifikasi Kesehatan":
    st.subheader("🏥 Klasifikasi Daerah Sehat vs Tidak Sehat")

    try:
        feat_clf = get_feature_list("clf", model_features["clf"], expected)
        Xk = clean_input_data(df[feat_clf].copy())
        y_pred = clf_model.predict(Xk)

        df_vis = df.copy()
        df_vis["Prediksi_Sehat"] = np.where(y_pred == 1, "Sehat", "Tidak Sehat")

        draw_choropleth(
            df_vis,
            color_col="Prediksi_Sehat",
            title="🗺️ Peta Klasifikasi Daerah Sehat vs Tidak Sehat",
            discrete=True,
            discrete_map={"Sehat": "green", "Tidak Sehat": "red"}
        )
    except Exception as e:
        st.error(f"❌ Gagal menjalankan klasifikasi: {e}")

# ================================================================
# MODE: REGRESI (PREDIKSI STUNTING TAHUN DEPAN)
# ================================================================
else:
    st.subheader("📈 Prediksi Stunting Tahun Depan")

    try:
        feat_reg = get_feature_list("reg", model_features["reg"], expected)
        Xr = clean_input_data(df[feat_reg].copy())
        y_pred = reg_model.predict(Xr)

        df_vis = df.copy()
        df_vis["Prediksi_Stunting_TahunDepan"] = y_pred

        draw_choropleth(
            df_vis,
            color_col="Prediksi_Stunting_TahunDepan",
            title="🗺️ Prediksi Stunting Tahun Depan (%)",
            color_scale="RdYlGn_r",
            discrete=False
        )

        st.dataframe(
            df_vis[["Provinsi", "Prediksi_Stunting_TahunDepan"]]
            .sort_values("Prediksi_Stunting_TahunDepan")
            .reset_index(drop=True)
        )
    except Exception as e:
        st.error(f"❌ Gagal menjalankan prediksi: {e}")