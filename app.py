# -*- coding: utf-8 -*-
"""app

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1zYTQrzw4n6dTT3PZ44hCY9qsoNeg4k8d
"""

# ================================================================
# STREAMLIT APP - STUNTING INDONESIA DASHBOARD (FINAL RESILIENT)
# ================================================================

import streamlit as st
import pandas as pd
import numpy as np
import plotly.express as px
import joblib, os, json, requests

# ------------------------------------------------
# App setup
# ------------------------------------------------
st.set_page_config(page_title="📊 Dashboard Stunting Indonesia", layout="wide")
st.title("🇮🇩 Dashboard Analisis Stunting Indonesia")
st.markdown("### *Clustering, Klasifikasi, dan Prediksi Stunting berbasis data sosio-ekonomi*")
st.markdown("---")

# ------------------------------------------------
# Utility: rename kolom agar sinkron dg training
# ------------------------------------------------
RENAME_MAP = {
    "Angka Harapan Hidup (AHH) Menurut Provinsi dan Jenis Kelamin (Tahun)": "Angka_Harapan_Hidup",
    "Persentase Rumah Tangga yang Memiliki Akses terhadap Sanitasi Layak Menurut Provinsi dan Klasifikasi Desa (Persen)": "Akses_Sanitasi_Layak",
    "Rumah Tangga yang Memiliki Akses Terhadap Sumber Air Minum Layak": "Akses_Air_Layak",
    "Persentase Rumah Tangga dengan Sumber Air Minum Air Dalam Kemasan": "Air_Kemasan",
    "Indeks Pembangunan Manusia": "IPM",
    "Prevalensi Ketidakcukupan Konsumsi Pangan (Persen)": "Konsumsi_Pangan_Tidak_Cukup",
    "Realisasi Jumlah Keluarga Penerima Manfaat (KPM) Bantuan Sosial Pangan (BANSOS PANGAN)": "Jumlah_KPM_Bansos",
    "Realisasi Anggaran Bantuan Sosial Pangan (BANSOS PANGAN) (Rp)": "Anggaran_Bansos",
    "Angka Melek Aksara Penduduk 15-59 Tahun Menurut Provinsi": "Melek_Aksara",
    "Tingkat Pengangguran Terbuka Menurut Provinsi (Persen)": "Tingkat_Pengangguran",
    "Persentase Anak Umur 12-23 Bulan yang Menerima Imunisasi Dasar Lengkap Menurut Provinsi (Persen)": "Imunisasi_Lengkap",
    "Rata-Rata Lama Sekolah Penduduk Umur 15 Tahun ke Atas Menurut Provinsi": "Lama_Sekolah",
    "Garis Kemiskinan Makanan (Rupiah/Kapita/Bulan) Menurut Provinsi dan Daerah": "Garis_Kemiskinan_Makanan",
    "Indeks Kedalaman Kemiskinan (P1) Menurut Provinsi dan Daerah (Persen)": "Kedalaman_Kemiskinan"
}

FEATURES_BASE = [
    "IPM","Akses_Sanitasi_Layak","Akses_Air_Layak","Air_Kemasan",
    "Konsumsi_Pangan_Tidak_Cukup","Jumlah_KPM_Bansos","Anggaran_Bansos",
    "Melek_Aksara","Tingkat_Pengangguran","Imunisasi_Lengkap",
    "Lama_Sekolah","Garis_Kemiskinan_Makanan","Kedalaman_Kemiskinan"
]

# ------------------------------------------------
# Load data
# ------------------------------------------------
@st.cache_data
def load_data():
    df_ = pd.read_excel("DATA_SUM_STUNTING.xlsx")
    # bersihkan spasi aneh di nama kolom
    df_.columns = [c.strip() for c in df_.columns]
    # rename agar sama seperti training
    df_.rename(columns=RENAME_MAP, inplace=True)
    return df_

df = load_data()

if "Provinsi" not in df.columns:
    st.error("❌ Kolom 'Provinsi' tidak ditemukan. Pastikan Excel memiliki kolom 'Provinsi'.")
    st.stop()

# ------------------------------------------------
# Numeric cleaning
# ------------------------------------------------
def clean_input_data(dfin: pd.DataFrame) -> pd.DataFrame:
    d = dfin.copy()
    for col in d.columns:
        if d[col].dtype == object:
            d[col] = d[col].replace(",", ".", regex=True)
            d[col] = pd.to_numeric(d[col], errors="coerce")
    d = d.fillna(d.median(numeric_only=True))
    return d

# ------------------------------------------------
# GeoJSON loader (multi source) + fallback titik
# ------------------------------------------------
PROV_COORDS = {
    "ACEH": (4.70, 96.75), "SUMATERA UTARA": (2.11, 99.55), "SUMATERA BARAT": (-0.74, 100.80),
    "RIAU": (0.29, 101.71), "KEPULAUAN RIAU": (0.92, 104.45), "JAMBI": (-1.61, 103.61),
    "SUMATERA SELATAN": (-3.32, 104.91), "BENGKULU": (-3.58, 102.35), "LAMPUNG": (-4.56, 105.41),
    "KEP. BANGKA BELITUNG": (-2.74, 106.44), "BANTEN": (-6.41, 106.06), "DKI JAKARTA": (-6.17, 106.83),
    "JAWA BARAT": (-6.89, 107.64), "JAWA TENGAH": (-7.15, 110.14), "D I YOGYAKARTA": (-7.79, 110.37),
    "JAWA TIMUR": (-7.54, 112.24), "BALI": (-8.34, 115.09), "NUSA TENGGARA BARAT": (-8.65, 117.36),
    "NUSA TENGGARA TIMUR": (-8.66, 121.08), "KALIMANTAN BARAT": (-0.13, 111.10), "KALIMANTAN TENGAH": (-1.68, 113.38),
    "KALIMANTAN SELATAN": (-3.09, 115.28), "KALIMANTAN TIMUR": (0.54, 116.42), "KALIMANTAN UTARA": (2.84, 117.39),
    "SULAWESI UTARA": (1.49, 124.84), "GORONTALO": (0.70, 122.45), "SULAWESI TENGAH": (-1.43, 121.45),
    "SULAWESI BARAT": (-2.84, 119.23), "SULAWESI SELATAN": (-3.67, 119.97), "SULAWESI TENGGARA": (-4.14, 122.17),
    "MALUKU": (-3.24, 130.15), "MALUKU UTARA": (1.57, 127.81), "PAPUA": (-4.27, 138.08),
    "PAPUA BARAT": (-1.34, 133.17), "PAPUA BARAT DAYA": (-0.88, 131.26), "PAPUA PEGUNUNGAN": (-4.10, 138.94),
    "PAPUA SELATAN": (-8.49, 140.40), "PAPUA TENGAH": (-3.36, 135.50)
}

@st.cache_data
def load_geojson():
    urls = [
        # repo utama (kadang berubah)
        "https://raw.githubusercontent.com/superpikar/indonesia-geojson/master/indonesia-prov.geojson",
        # alternatif lain (silakan tambahkan repo lain jika punya)
        "https://raw.githubusercontent.com/superpikar/indonesia-geojson/master/indonesia-province.geojson",
    ]
    for url in urls:
        try:
            r = requests.get(url, timeout=10)
            r.raise_for_status()
            st.success(f"🌍 GeoJSON dimuat: {url}")
            return r.json()
        except Exception:
            continue

    # fallback lokal
    local_path = "indonesia_province.geojson"
    if os.path.exists(local_path):
        try:
            with open(local_path, "r", encoding="utf-8") as f:
                st.info("📁 GeoJSON lokal digunakan.")
                return json.load(f)
        except Exception as e:
            st.warning(f"⚠️ GeoJSON lokal bermasalah: {e}")

    # fallback titik
    st.error("❌ Tidak ada GeoJSON poligon yang valid. Menggunakan peta titik koordinat manual.")
    dummy = {"type": "FeatureCollection", "features": []}
    for prov, (lat, lon) in PROV_COORDS.items():
        dummy["features"].append({
            "type": "Feature",
            "properties": {"Propinsi": prov},
            "geometry": {"type": "Point", "coordinates": [lon, lat]},
        })
    return dummy

geojson = load_geojson()

def is_polygon_geojson(gj: dict) -> bool:
    try:
        feats = gj.get("features", [])
        if not feats:
            return False
        geom_type = feats[0].get("geometry", {}).get("type", "")
        return geom_type in ("Polygon", "MultiPolygon")
    except Exception:
        return False

def detect_featureid_prop(gj: dict, province_series: pd.Series) -> str:
    """
    Coba beberapa kemungkinan kunci properti pada GeoJSON:
    returns "properties.<KEY>"
    """
    candidates = ["Propinsi", "Provinsi", "name", "NAME_1", "state", "provinsi"]
    feats = gj.get("features", [])
    if not feats:
        return "properties.Propinsi"
    props_keys = list(feats[0].get("properties", {}).keys())

    # normalisasi nama provinsi: upper tanpa ekstra spasi
    prov_norm = set(province_series.str.upper().str.strip())

    best_key = None
    best_overlap = -1
    for key in candidates + props_keys:
        vals = [f.get("properties", {}).get(key, "") for f in feats]
        vals_norm = set([str(v).upper().strip() for v in vals])
        overlap = len(prov_norm.intersection(vals_norm))
        if overlap > best_overlap:
            best_overlap = overlap
            best_key = key
    return f"properties.{best_key}" if best_key else "properties.Propinsi"

# ------------------------------------------------
# Load model & expected features
# ------------------------------------------------
@st.cache_resource
def load_models_and_meta():
    cluster = joblib.load("models/cluster_model.pkl")
    clf = joblib.load("models/classification_model.pkl")
    reg = joblib.load("models/regression_model.pkl")
    # metadata fitur
    exp = {"features_base": None, "features_all": None}
    meta_path = "models/expected_features.json"
    if os.path.exists(meta_path):
        try:
            with open(meta_path, "r", encoding="utf-8") as f:
                exp = json.load(f)
        except Exception:
            pass
    model_feats = {
        "cluster": getattr(cluster, "feature_names_in_", None),
        "clf": getattr(clf, "feature_names_in_", None),
        "reg": getattr(reg, "feature_names_in_", None),
    }
    return cluster, clf, reg, model_feats, exp

cluster_model, clf_model, reg_model, model_features, expected = load_models_and_meta()

def get_feature_list(role: str) -> list:
    """
    role: 'cluster' | 'clf' | 'reg'
    Prioritas: expected_features.json -> feature_names_in_ -> fallback numeric.
    """
    if role == "cluster":
        if expected.get("features_base"):
            return expected["features_base"]
        if model_features["cluster"] is not None:
            return list(model_features["cluster"])
        return FEATURES_BASE  # fallback masuk akal
    else:  # clf / reg
        if expected.get("features_all"):
            return expected["features_all"]
        if model_features[role] is not None:
            return list(model_features[role])
        # fallback: semua numerik
        return df.select_dtypes(include=[np.number]).columns.tolist()

def ensure_features(X: pd.DataFrame, feat_list: list, context: str) -> pd.DataFrame:
    """
    Pastikan semua kolom fitur ada; bila hilang → tambahkan bernilai 0
    dan tampilkan info kolom yang sebelumnya tidak ada.
    """
    missing = [c for c in feat_list if c not in X.columns]
    if missing:
        st.warning(f"ℹ️ ({context}) Menambahkan kolom yang hilang (diisi 0): {missing}")
        for c in missing:
            X[c] = 0
    # urutkan kolom sesuai training
    return X[feat_list]

# ------------------------------------------------
# Sidebar
# ------------------------------------------------
st.sidebar.title("📁 Pilih Fitur Analisis")
mode = st.sidebar.radio("Pilih mode:", ["🧭 Clustering", "🏥 Klasifikasi Kesehatan", "📈 Prediksi Stunting"])

# ------------------------------------------------
# Map helper
# ------------------------------------------------
def plot_map(df_map, color_col, title, discrete=False, discrete_map=None):
    if is_polygon_geojson(geojson):
        featureidkey = detect_featureid_prop(geojson, df_map["Provinsi"])
        if discrete:
            fig = px.choropleth(
                df_map, geojson=geojson, featureidkey=featureidkey,
                locations="Provinsi", color=color_col,
                color_discrete_map=discrete_map or {}, title=title
            )
        else:
            fig = px.choropleth(
                df_map, geojson=geojson, featureidkey=featureidkey,
                locations="Provinsi", color=color_col,
                color_continuous_scale="RdYlGn_r", title=title
            )
        fig.update_geos(fitbounds="locations", visible=False)
        st.plotly_chart(fig, use_container_width=True)
    else:
        # fallback: peta titik (scatter_geo) menggunakan PROV_COORDS
        dfp = df_map.copy()
        dfp["prov_up"] = dfp["Provinsi"].str.upper().str.strip()
        dfp["lat"] = dfp["prov_up"].map(lambda p: PROV_COORDS.get(p, (np.nan, np.nan))[0])
        dfp["lon"] = dfp["prov_up"].map(lambda p: PROV_COORDS.get(p, (np.nan, np.nan))[1])
        dfp = dfp.dropna(subset=["lat","lon"])
        if discrete:
            fig = px.scatter_geo(dfp, lat="lat", lon="lon", color=color_col, hover_name="Provinsi", title=title)
        else:
            fig = px.scatter_geo(dfp, lat="lat", lon="lon", color=color_col, hover_name="Provinsi",
                                 color_continuous_scale="RdYlGn_r", title=title)
        fig.update_geos(fitbounds="locations", showcountries=True)
        st.plotly_chart(fig, use_container_width=True)

# ------------------------------------------------
# Modes
# ------------------------------------------------
if mode == "🧭 Clustering":
    st.subheader("🧭 Clustering Tingkat Kerentanan Stunting per Provinsi")
    try:
        feats = get_feature_list("cluster")
        X = clean_input_data(df[feats].copy())
        X = ensure_features(X, feats, "Clustering")
        cluster_labels = cluster_model.predict(X)

        out = df.copy()
        out["Cluster"] = cluster_labels
        cluster_map = {0: "Sejahtera (Maju)", 1: "Sedang (Mainstream)", 2: "Rentan (Tertinggal)"}
        out["Kategori_Cluster"] = out["Cluster"].map(cluster_map)

        plot_map(out, "Kategori_Cluster", "🗺️ Peta Clustering Kerentanan Stunting",
                 discrete=True, discrete_map={"Sejahtera (Maju)": "green",
                                              "Sedang (Mainstream)": "orange",
                                              "Rentan (Tertinggal)": "red"})
        st.caption("ℹ️ Hijau = Sejahtera (Maju) · Oranye = Sedang (Mainstream) · Merah = Rentan (Tertinggal)")
    except Exception as e:
        st.error(f"❌ Gagal menjalankan clustering: {e}")

elif mode == "🏥 Klasifikasi Kesehatan":
    st.subheader("🏥 Klasifikasi Daerah Sehat vs Tidak Sehat")
    try:
        feats = get_feature_list("clf")
        X = clean_input_data(df[feats].copy())
        X = ensure_features(X, feats, "Klasifikasi")
        y_pred = clf_model.predict(X)

        out = df.copy()
        out["Prediksi_Sehat"] = np.where(y_pred == 1, "Sehat", "Tidak Sehat")
        plot_map(out, "Prediksi_Sehat", "🗺️ Peta Klasifikasi Daerah Sehat vs Tidak Sehat",
                 discrete=True, discrete_map={"Sehat": "green", "Tidak Sehat": "red"})
    except Exception as e:
        st.error(f"❌ Gagal menjalankan klasifikasi: {e}")

else:
    st.subheader("📈 Prediksi Stunting Tahun Depan")
    try:
        feats = get_feature_list("reg")
        X = clean_input_data(df[feats].copy())
        X = ensure_features(X, feats, "Regresi")
        y_pred = reg_model.predict(X)

        out = df.copy()
        out["Prediksi_Stunting_TahunDepan"] = y_pred
        plot_map(out, "Prediksi_Stunting_TahunDepan", "🗺️ Prediksi Stunting Tahun Depan (%)", discrete=False)

        st.dataframe(out[["Provinsi", "Prediksi_Stunting_TahunDepan"]]
                     .sort_values("Prediksi_Stunting_TahunDepan")
                     .reset_index(drop=True))
    except Exception as e:
        st.error(f"❌ Gagal menjalankan prediksi: {e}")